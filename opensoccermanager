#!/usr/bin/env python3

#  OpenSoccerManager
#
#  Copyright 2015 Andrew Steele <andrew.steele@opensoccermanager.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.


from gi.repository import Gtk
import os
import subprocess

import ai
import business
import calculator
import constants
import data
import database
import dialogs
import display
import evaluation
import events
import fileio
import finances
import game
import information
import match
import menu
import money
import music
import preferences
import sales
import squad
import stadium
import team
import training
import transfer
import version
import view
import widgets


class Window(Gtk.Window):
    def __init__(self):
        iconpath = os.path.join("resources", "logo.svg")

        Gtk.Window.__init__(self)
        self.set_title(version.NAME)
        self.set_icon_from_file(iconpath)
        self.connect("delete-event", exit_game)

        game.accelgroup = Gtk.AccelGroup()
        self.add_accel_group(game.accelgroup)

    def run(self):
        self.add(screenmain)

        game.preferences.readfile()
        fileio.check_config()

        self.show_all()

        if game.music:
            game.player.play()


class ScreenMain(Gtk.Grid):
    def __init__(self):
        Gtk.Grid.__init__(self)
        self.set_row_spacing(40)
        self.set_border_width(5)

        buttonbox = Gtk.ButtonBox()
        buttonbox.set_hexpand(True)
        buttonbox.set_vexpand(True)
        buttonbox.set_orientation(Gtk.Orientation.VERTICAL)
        buttonbox.set_layout(Gtk.ButtonBoxStyle.EXPAND)
        buttonbox.set_border_width(25)
        self.attach(buttonbox, 1, 1, 1, 1)

        buttonNewGame = widgets.Button("_New Game")
        buttonNewGame.set_tooltip_text("Start a new game")
        buttonNewGame.connect("clicked", self.new_game_clicked)
        buttonbox.add(buttonNewGame)
        buttonLoadGame = widgets.Button("_Load Game")
        buttonLoadGame.set_tooltip_text("Load a previously saved game")
        buttonLoadGame.connect("clicked", self.load_game_clicked)
        buttonbox.add(buttonLoadGame)
        buttonDeleteGame = widgets.Button("_Delete Game")
        buttonDeleteGame.set_tooltip_text("Delete a previously saved game")
        buttonDeleteGame.connect("clicked", lambda a: dialogs.delete_dialog())
        buttonbox.add(buttonDeleteGame)
        buttonPreferences = widgets.Button("_Preferences")
        buttonPreferences.set_tooltip_text("Adjust game settings")
        buttonPreferences.connect("clicked", lambda a: dialogs.preferences_dialog())
        buttonbox.add(buttonPreferences)
        buttonEditor = widgets.Button("_Data Editor")
        buttonEditor.set_tooltip_text("Create new or edit existing game database")
        buttonEditor.connect("clicked", self.editor_clicked)
        buttonbox.add(buttonEditor)
        buttonQuit = widgets.Button("_Quit")
        buttonQuit.set_tooltip_text("Quit the game")
        buttonQuit.connect("clicked", exit_game)
        buttonbox.add(buttonQuit)

        label = widgets.AlignedLabel("Version %s (Build %s)" % (version.VERSION, version.DATE))
        self.attach(label, 0, 2, 1, 1)

        label = Gtk.Label()
        label.set_markup("<a href='%s'>%s Website</a>" % (version.WEBSITE, version.NAME))
        label.set_alignment(1, 0.5)
        self.attach(label, 2, 2, 1, 1)

    def new_game_clicked(self, button):
        game.window.remove(screenmain)
        game.window.add(screendetails)

        screendetails.run()

    def load_game_clicked(self, button):
        open_dialog = dialogs.OpenDialog()

        if open_dialog.display():
            game.window.remove(screenmain)
            game.window.add(screengame)
            screengame.run()

            screen_loader(game.active_screen_id)

    def editor_clicked(self, button):
        try:
            filepath = os.path.join("editor", "editor.py")
            subprocess.Popen(filepath, shell=False)
        except FileNotFoundError:
            dialogs.file_not_found_error()


class ScreenDetails(Gtk.Grid):
    '''
    Grab the details for the game including manager name, selected club,
    and finances.
    '''
    def __init__(self):
        Gtk.Grid.__init__(self)
        self.set_row_spacing(5)
        self.set_column_spacing(5)
        self.set_border_width(5)

        self.liststoreName = Gtk.ListStore(str)
        self.liststoreClubs = Gtk.ListStore(int, str)

        treemodelsort = Gtk.TreeModelSort(self.liststoreClubs)
        treemodelsort.set_sort_column_id(1, Gtk.SortType.ASCENDING)

        label = widgets.AlignedLabel("_Name")
        self.attach(label, 0, 0, 1, 1)
        self.comboboxName = Gtk.ComboBoxText.new_with_entry()
        self.comboboxName.set_model(self.liststoreName)
        self.entryName = self.comboboxName.get_child()
        self.entryName.connect("changed", self.continue_status)
        label.set_mnemonic_widget(self.comboboxName)
        self.attach(self.comboboxName, 1, 0, 1, 1)

        label = widgets.AlignedLabel("_Database")
        self.attach(label, 0, 1, 1, 1)
        self.filechooserDatabase = Gtk.FileChooserButton()
        self.filechooserDatabase.set_title("Select Database")
        self.filechooserDatabase.set_action(Gtk.FileChooserAction.OPEN)
        self.filechooserDatabase.connect("file-set", self.file_chooser_set)
        filefilter = Gtk.FileFilter()
        filefilter.set_name("Database Files")
        filefilter.add_pattern("*.db")
        self.filechooserDatabase.add_filter(filefilter)
        label.set_mnemonic_widget(self.filechooserDatabase)
        self.attach(self.filechooserDatabase, 1, 1, 1, 1)

        label = widgets.AlignedLabel("_Club")
        self.attach(label, 0, 2, 1, 1)
        cellrenderertext = Gtk.CellRendererText()
        self.comboboxClub = Gtk.ComboBox()
        self.comboboxClub.set_model(treemodelsort)
        self.comboboxClub.pack_start(cellrenderertext, True)
        self.comboboxClub.add_attribute(cellrenderertext, "text", 1)
        label.set_mnemonic_widget(self.comboboxClub)
        self.attach(self.comboboxClub, 1, 2, 1, 1)

        label = widgets.AlignedLabel("_Finances")
        self.attach(label, 0, 3, 1, 1)
        self.radiobuttonFinancesRep = Gtk.RadioButton("Reputation-Based Finances")
        self.radiobuttonFinancesRep.connect("toggled", self.finances_changed)
        label.set_mnemonic_widget(self.radiobuttonFinancesRep)
        self.attach(self.radiobuttonFinancesRep, 1, 3, 1, 1)
        self.radiobuttonFinancesUSM = Gtk.RadioButton("USM-Based Finances")
        self.radiobuttonFinancesUSM.join_group(self.radiobuttonFinancesRep)
        self.radiobuttonFinancesUSM.connect("toggled", self.finances_changed)
        self.attach(self.radiobuttonFinancesUSM, 2, 3, 1, 1)
        self.comboboxFinances = Gtk.ComboBoxText()
        self.comboboxFinances.set_sensitive(False)
        self.attach(self.comboboxFinances, 1, 4, 2, 1)

        buttonbox = Gtk.ButtonBox()
        buttonbox.set_spacing(5)
        buttonbox.set_layout(Gtk.ButtonBoxStyle.END)
        self.attach(buttonbox, 0, 5, 3, 1)
        buttonBack = widgets.Button("_Back")
        buttonBack.connect("clicked", self.back_button_clicked)
        buttonbox.add(buttonBack)
        self.buttonContinue = widgets.Button("_Continue")
        self.buttonContinue.set_sensitive(False)
        self.buttonContinue.connect("clicked", self.continue_button_clicked)
        buttonbox.add(self.buttonContinue)

    def run(self):
        game.database.connect()
        data.datainit()

        # Set database
        filepath = os.path.join("databases", "%s" % (game.database_filename))
        self.filechooserDatabase.select_filename(filepath)

        # Load financials
        self.comboboxFinances.remove_all()

        for key, item in constants.money.items():
            amount = display.currency(item[0])
            self.comboboxFinances.append(str(key), "%s (%s)" % (item[1], amount))

        # Load manager names
        self.liststoreName.clear()
        [self.liststoreName.append([name]) for name in fileio.read_names()]

        # Load list of clubs
        self.liststoreClubs.clear()
        [self.liststoreClubs.append([clubid, club.name]) for clubid, club in game.clubs.items()]

        self.entryName.set_text("")
        self.comboboxClub.set_active(0)
        self.radiobuttonFinancesRep.set_active(True)
        self.comboboxFinances.set_active(0)

        self.show_all()
        self.entryName.grab_focus()

    def file_chooser_set(self, filechooserbutton):
        game.database_filename = filechooserbutton.get_filename()
        game.database.connect(game.database_filename)
        data.datainit()

        self.liststoreClubs.clear()
        [self.liststoreClubs.append([clubid, club.name]) for clubid, club in game.clubs.items()]
        self.comboboxClub.set_active(0)

    def finances_changed(self, radiobutton):
        active = self.radiobuttonFinancesUSM.get_active()
        self.comboboxFinances.set_sensitive(active)

    def continue_status(self, entry):
        sensitive = entry.get_text_length() > 0
        self.buttonContinue.set_sensitive(sensitive)

    def back_button_clicked(self, button):
        game.window.remove(screendetails)
        game.window.add(screenmain)

    def continue_button_clicked(self, button):
        # Get club ID number from combobox
        treeiter = self.comboboxClub.get_active_iter()
        model = self.comboboxClub.get_model()
        game.teamid = model[treeiter][0]

        # Save manager name entered by player
        game.clubs[game.teamid].manager = self.entryName.get_text()

        add = True

        for count, item in enumerate(self.liststoreName):
            if item[0] == game.clubs[game.teamid].manager:
                add = False

                del(self.liststoreName[count])
                self.liststoreName.prepend([game.clubs[game.teamid].manager])

        if add:
            self.liststoreName.prepend([game.clubs[game.teamid].manager])

        names = [key[0] for key in self.liststoreName]
        fileio.write_names(names)

        self.complete_data_load()

        game.window.remove(screendetails)
        game.window.add(screengame)
        screen_loader(game.start_screen)
        screengame.run()

    def complete_data_load(self):
        '''
        Used to load remaining data and populate game with usable values
        '''
        # Grab finance setup
        if self.radiobuttonFinancesUSM.get_active():
            finances = int(self.comboboxFinances.get_active_id())
        else:
            finances = -1

        data.dataloader(finances)

        money.calculate_loan()
        money.calculate_overdraft()
        money.calculate_grant()
        money.flotation()
        events.update_records()
        events.expectation()

        # AI-related
        ai.transfer_list()
        ai.loan_list()
        ai.team_training()

        game.database.connection.close()


class ScreenGame(Gtk.Grid):
    def __init__(self):
        Gtk.Grid.__init__(self)

        game.menu = menu.Menu()
        self.attach(game.menu, 0, 0, 1, 1)

        game.menu.menuitemNew.connect("activate", self.new_game_clicked)
        game.menu.menuitemLoad.connect("activate", self.load_game_clicked)
        game.menu.menuitemSave.connect("activate", self.save_game_clicked)
        game.menu.menuitemDelete.connect("activate", lambda a: dialogs.delete_dialog())
        game.menu.menuitemQuit.connect("activate", exit_game)

        game.menu.menuitemManager.connect("activate", self.name_change)
        game.menu.menuitemPreferences.connect("activate", self.preferences_dialog)

        game.menu.menuitemPlayers.connect("activate", lambda i: screen_loader(20))
        game.menu.menuitemComparison.connect("activate", self.player_comparison)
        game.menu.menuitemNews.connect("activate", lambda i: screen_loader(3))
        game.menu.menuitemFixtures.connect("activate", lambda i: screen_loader(2))
        game.menu.menuitemResults.connect("activate", lambda i: screen_loader(6))
        game.menu.menuitemStandings.connect("activate", lambda i: screen_loader(5))
        game.menu.menuitemCharts.connect("activate", lambda i: screen_loader(30))
        game.menu.menuitemEvaluation.connect("activate", lambda i: screen_loader(25))
        game.menu.menuitemOpposition.connect("activate", self.view_opposition)
        game.menu.menuitemNegotiations.connect("activate", lambda i: screen_loader(21))
        game.menu.menuitemShortlist.connect("activate", lambda i: screen_loader(22))
        game.menu.menuitemStatistics.connect("activate", lambda i: screen_loader(29))

        game.menu.menuitemStadium.connect("activate", lambda i: screen_loader(10))
        game.menu.menuitemBuildings.connect("activate", lambda i: screen_loader(14))
        game.menu.menuitemTickets.connect("activate", lambda i: screen_loader(19))
        game.menu.menuitemSponsorship.connect("activate", lambda i: dialogs.sponsorship())
        game.menu.menuitemAdvertising.connect("activate", lambda i: screen_loader(16))
        game.menu.menuitemMerchandise.connect("activate", lambda i: screen_loader(17))
        game.menu.menuitemCatering.connect("activate", lambda i: screen_loader(18))
        game.menu.menuitemFinances.connect("activate", lambda i: screen_loader(11))
        game.menu.menuitemAccounts.connect("activate", lambda i: screen_loader(12))

        game.menu.menuitemSquad.connect("activate", lambda i: screen_loader(1))
        game.menu.menuitemTactics.connect("activate", lambda i: screen_loader(4))
        game.menu.menuitemTeamTraining.connect("activate", lambda i: screen_loader(7))
        game.menu.menuitemIndTraining.connect("activate", lambda i: screen_loader(9))
        game.menu.menuitemTrainingCamp.connect("activate", lambda i: screen_loader(8))
        game.menu.menuitemInjSus.connect("activate", lambda i: screen_loader(24))
        game.menu.menuitemStaff.connect("activate", lambda i: screen_loader(23))

        game.menu.menuitemContents.connect("activate", lambda a: dialogs.help_content())
        game.menu.menuitemInformation.connect("activate", lambda a: dialogs.information_dialog())
        game.menu.menuitemAbout.connect("activate", lambda a: dialogs.about())

        grid = Gtk.Grid()
        grid.set_border_width(1)
        grid.set_column_spacing(5)
        self.attach(grid, 0, 2, 1, 1)

        widgets.date.update()
        grid.attach(widgets.date, 0, 0, 1, 1)

        widgets.news.connect("clicked", self.news_activated)
        grid.attach(widgets.news, 1, 0, 1, 1)

        label = Gtk.Label()  # Intentional blank label
        label.set_hexpand(True)
        grid.attach(label, 2, 0, 1, 1)

        game.labelNextMatch = Gtk.Label()
        grid.attach(game.labelNextMatch, 3, 0, 1, 1)

        widgets.continuegame = widgets.Button("_Continue Game")
        widgets.continuegame.connect("clicked", continuegame.continue_game)
        grid.attach(widgets.continuegame, 4, 0, 1, 1)

    def run(self):
        self.show_all()

    def name_change(self, menuitem):
        club = game.clubs[game.teamid]
        previous = club.manager

        name_change = dialogs.NameChange()

        if name_change.display():
            news = []

            for item in game.news:
                item[1] = item[1].replace(previous, club.manager)
                item[2] = item[2].replace(previous, club.manager)

                news.append(item)

            game.news = news

            screen_loader(game.active_screen_id)

    def news_activated(self, button):
        screen_loader(3)

    def player_comparison(self, menuitem):
        if game.comparison == [None, None]:
            dialogs.error(3)
        elif not game.comparison[0] or not game.comparison[1]:
            dialogs.error(5)
        else:
            dialogs.comparison()

    def view_opposition(self, menuitem):
        opposition_dialog = dialogs.Opposition()
        opposition_dialog.display()

    def new_game_clicked(self, menuitem):
        if not dialogs.exit_game(leave=True):
            game.window.remove(screengame)
            game.window.add(screenmain)

            # Reset teamid to zero to prevent having to confirm quit
            game.teamid = 0

    def load_game_clicked(self, menuitem):
        open_dialog = dialogs.OpenDialog()

        if open_dialog.display():
            screen_loader(game.active_screen_id)

        open_dialog.destroy()

    def save_game_clicked(self, menuitem):
        save_dialog = dialogs.SaveDialog()
        save_dialog.display()
        save_dialog.destroy()

    def preferences_dialog(self, menuitem):
        dialogs.preferences_dialog()

        screen_loader(game.active_screen_id)


class ContinueGame:
    def continue_game(self, widget):
        update_valid = True

        current_date = "%i/%i" % (game.date, game.month)

        if game.week == len(constants.dates):
            if game.dateindex == len(constants.dates[game.week - 1]) - 1:
                # End of season events
                events.end_of_season()

        if game.eventindex <= len(constants.events) - 1:
            event = constants.events[game.eventindex]
        else:
            event = None

        if current_date == event:
            # Team names to be passed to proceed dialog
            for item in game.fixtures[game.fixturesindex]:
                if game.teamid in (item[0], item[1]):
                    match = item

            if game.teamid == match[0]:
                team = match[1]
            else:
                team = match[0]

            opposition = game.clubs[team].name
            proceed = dialogs.proceed_to_game(opposition)

            error = True

            if proceed:
                error = self.check_squad()

                if error:
                    update_valid = False
            else:
                update_valid = False

            if not error:
                game.eventindex += 1
                self.initiate_game()
                game.proceed = False
        elif game.proceed and update_valid:
            self.update_date()
        elif not game.proceed:
            screen_loader(1)

            game.menu.set_sensitive(True)
            widgets.news.set_sensitive(True)
            game.proceed = True

        # Unread news status
        if game.unreadnews:
            widgets.news.show()

        # Display next match
        if "%i/%i" % (game.date, game.month) == constants.events[game.fixturesindex]:
            for match in game.fixtures[game.fixturesindex]:
                if game.teamid in match:
                    team1 = game.clubs[match[0]].name
                    team2 = game.clubs[match[1]].name
                    game.labelNextMatch.set_label("Today's Match: %s - %s" % (team1, team2))
        else:
            game.labelNextMatch.set_label("")

    def update_date(self):
        game.date = constants.dates[game.week - 1][game.dateindex]

        if game.dateprev > game.date:
            game.dateprev = 0

            if game.month == 12:
                game.month = 1
                game.year += 1
            else:
                game.month += 1

        if len(constants.dates[game.week - 1]) - 1 > game.dateindex:
            game.dateindex += 1
        else:
            game.dateprev = constants.dates[game.week - 1][game.dateindex]
            game.dateindex = 0
            game.week += 1

            # Process end of week events
            events.reset_accounts()
            money.pay_wages()
            events.update_contracts()
            events.update_advertising()
            events.update_sponsorship()
            events.refresh_staff()
            events.team_training()
            events.individual_training()
            transfer.process_loan()
            ai.renew_contract()
            events.injury_period()
            events.update_condition()
            events.update_maintenance()
            money.float_club()
            money.pay_overdraft()
            money.pay_loan()
            money.process_grant()

        # Process everyday events
        transfer.transfer()
        events.injury()
        transfer.ai_enquiry()
        ai.advertising()
        evaluation.update()

        # Age players
        for playerid, player in game.players.items():
            player.age = events.age(player.date_of_birth)

        # Initiate first sponsorship offer
        if (game.date, game.month) == (4, 8):
            events.update_sponsorship()

        # Stop sale of season tickets and deposit earnings
        if (game.date, game.month) == (16, 8):
            if game.season_tickets_status == 0:
                game.season_tickets_status = 1

                sales.season_tickets()

        # Player value adjustments
        for playerid, player in game.players.items():
            player.value = calculator.value(playerid)

        widgets.date.update()

        # Comment to prevent screen refresh on continue game - FASTER!
        screen_loader(game.active_screen_id)

    def initiate_game(self):
        screen_loader(99)

    def check_squad(self):
        '''
        Check whether the squad has been selected, determine the numbers
        and return whether the game can proceed or not.
        '''
        error = False

        for playerid in game.clubs[game.teamid].team.values():
            if playerid != 0:
                player = game.players[playerid]

                if player.injury_type != 0:
                    dialogs.error(6)
                    error = True

                if player.suspension_type != 0 and not error:
                    dialogs.error(7)
                    error = True

        if not error:
            team_count = 0
            sub_count = 0

            for count, item in enumerate(game.clubs[game.teamid].team.items()):
                if item[1] != 0:
                    if count < 11:
                        team_count += 1

                    if count >= 11:
                        sub_count += 1

            if team_count + 1 < 11:
                dialogs.not_enough_players(team_count)
                error = True
            elif sub_count + 1 < 5:
                answer = dialogs.not_enough_subs(sub_count)

                if not answer:
                    error = True

        return error


def screen_loader(index):
    # Screen to load and name of the screen to use for help file
    screens = {1: (obj_squad, "squad"),
               2: (obj_fixtures, "fixtures"),
               3: (obj_news, "news"),
               4: (obj_tactics, "tactics"),
               5: (obj_standings, "standings"),
               6: (obj_results, "results"),
               7: (obj_teamtraining, "teamtraining"),
               8: (obj_trainingcamp, "trainingcamp"),
               9: (obj_individualtraining, "individualtraining"),
               10: (obj_stadium, "stadium"),
               11: (obj_finances, "finances"),
               12: (obj_accounts, "accounts"),
               14: (obj_buildings, "buildings"),
               16: (obj_advertising, "advertising"),
               17: (obj_merchandise, "merchandise"),
               18: (obj_catering, "catering"),
               19: (obj_tickets, "tickets"),
               20: (obj_players, "players"),
               21: (obj_negotiations, "negotiations"),
               22: (obj_shortlist, "shortlist"),
               23: (obj_staff, "staff"),
               24: (obj_injsus, "injsus"),
               25: (obj_evaluation, "evaluation"),
               29: (obj_statistics, "statistics"),
               30: (obj_charts, "charts"),
               99: (obj_match, "match"),
              }

    if game.active_screen:
        if game.active_screen_id == index:
            game.active_screen.run()

            return
        else:
            screengame.remove(game.active_screen)

    screen = screens[index]
    game.active_screen = screen[0]
    game.active_screen.__name__ = screen[1]
    game.active_screen_id = index
    screengame.attach(game.active_screen, 0, 1, 1, 1)
    game.active_screen.run()


def exit_game(widget=None, event=None):
    def update_window_config():
        '''
        Save the window size and state to preferences when quitting.
        '''
        if game.window.is_maximized():
            game.preferences["INTERFACE"]["Maximized"] = "True"
        else:
            game.preferences["INTERFACE"]["Maximized"] = "False"
            width, height = game.window.get_size()
            game.preferences["INTERFACE"]["Width"] = str(width)
            game.preferences["INTERFACE"]["Height"] = str(height)

        game.preferences.writefile()

    if game.teamid == 0:
        update_window_config()
        Gtk.main_quit()
    else:
        state = dialogs.exit_game()

        if not state:
            update_window_config()
            Gtk.main_quit()

        return state


game.database = database.DB()
continuegame = ContinueGame()
game.preferences = preferences.Preferences()
game.player = music.Player()

widgets.date = widgets.Date()
widgets.news = widgets.News()

game.window = Window()
screenmain = ScreenMain()
screendetails = ScreenDetails()
screengame = ScreenGame()

obj_news = information.News()
obj_evaluation = information.Evaluation()
obj_charts = information.Charts()
obj_statistics = information.Statistics()
obj_fixtures = information.Fixtures()
obj_results = information.Results()
obj_standings = information.Standings()
obj_negotiations = view.Negotiations()
obj_shortlist = view.Shortlist()
obj_injsus = view.InjSus()
obj_teamtraining = training.TeamTraining()
obj_individualtraining = training.IndividualTraining()
obj_trainingcamp = training.TrainingCamp()
obj_tickets = business.Tickets()
obj_squad = squad.Squad()
obj_staff = team.Staff()
obj_tactics = team.Tactics()
obj_accounts = finances.Accounts()
obj_match = match.Match()
obj_advertising = business.Advertising()
obj_merchandise = business.Merchandise()
obj_catering = business.Catering()
obj_buildings = stadium.Buildings()
obj_players = view.Players()
obj_finances = finances.Finances()
obj_stadium = stadium.Stadium()

game.window.run()


if __name__ == "__main__":
    Gtk.main()
