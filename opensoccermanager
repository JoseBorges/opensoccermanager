#!/usr/bin/env python3

#  OpenSoccerManager
#
#  Copyright 2015 Andrew Steele <andrew.steele@opensoccermanager.org>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 3 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.


from gi.repository import Gtk
import os
import subprocess

import ai
import aitransfer
import business
import calculator
import constants
import data
import database
import dialogs
import display
import evaluation
import events
import fileio
import finances
import game
import information
import interface
import match
import menu
import money
import music
import preferences
import printing
import sales
import squad
import stadium
import staff
import structures
import team
import training
import transfer
import version
import view
import widgets


class Window(Gtk.Window):
    def __init__(self):
        preferences.preferences.readfile()

        iconpath = os.path.join("resources", "logo.svg")

        Gtk.Window.__init__(self)
        self.set_title(version.NAME)
        self.set_icon_from_file(iconpath)
        self.set_default_size(preferences.preferences.width,
                              preferences.preferences.height)

        if preferences.preferences.maximized:
            self.maximize()
        else:
            self.move(preferences.preferences.xposition,
                      preferences.preferences.yposition)

        self.connect("window-state-event", self.window_state_event)
        self.connect("delete-event", exit_game)

        game.accelgroup = Gtk.AccelGroup()
        self.add_accel_group(game.accelgroup)

    def window_state_event(self, widget, event):
        if self.is_maximized():
            self.move(preferences.preferences.xposition,
                      preferences.preferences.yposition)

    def screen_loader(self, index):
        screens = {1: self.screenSquad,
                   2: self.screenFixtures,
                   3: self.screenNews,
                   4: self.screenTactics,
                   5: self.screenStandings,
                   6: self.screenResults,
                   7: self.screenTeamTraining,
                   8: self.screenTrainingCamp,
                   9: self.screenIndividualTraining,
                   10: self.screenStadium,
                   11: self.screenFinances,
                   12: self.screenAccounts,
                   14: self.screenBuildings,
                   16: self.screenAdvertising,
                   17: self.screenMerchandise,
                   18: self.screenCatering,
                   19: self.screenTickets,
                   20: self.screenPlayers,
                   21: self.screenNegotiations,
                   22: self.screenShortlist,
                   23: self.screenStaff,
                   24: self.screenInjSus,
                   25: self.screenEvaluation,
                   29: self.screenStatistics,
                   30: self.screenCharts,
                   99: self.screenMatch,
                  }

        if game.active_screen:
            game.window.screenGame.remove(game.active_screen)

        game.active_screen = screens[index]
        game.active_screen_id = index
        game.window.screenGame.attach(game.active_screen, 0, 1, 1, 1)

        game.active_screen.set_border_width(5)
        game.active_screen.set_hexpand(True)
        game.active_screen.set_vexpand(True)

        game.active_screen.run()

    def run(self):
        self.screenMain = ScreenMain()
        self.screenDetails = ScreenDetails()
        self.screenGame = ScreenGame()

        self.screenSquad = squad.Squad()
        self.screenNews = information.News()
        self.screenEvaluation = information.Evaluation()
        self.screenCharts = information.Charts()
        self.screenStatistics = information.Statistics()
        self.screenFixtures = information.Fixtures()
        self.screenResults = information.Results()
        self.screenStandings = information.Standings()
        self.screenNegotiations = view.Negotiations()
        self.screenShortlist = view.Shortlist()
        self.screenInjSus = view.InjSus()
        self.screenTeamTraining = training.TeamTraining()
        self.screenIndividualTraining = training.IndividualTraining()
        self.screenTrainingCamp = training.TrainingCamp()
        self.screenTickets = business.Tickets()
        self.screenStaff = team.Staff()
        self.screenTactics = team.Tactics()
        self.screenAccounts = finances.Accounts()
        self.screenMatch = match.Match()
        self.screenAdvertising = business.Advertising()
        self.screenMerchandise = business.Merchandise()
        self.screenCatering = business.Catering()
        self.screenBuildings = stadium.Buildings()
        self.screenPlayers = view.Players()
        self.screenFinances = finances.Finances()
        self.screenStadium = stadium.Stadium()

        self.add(self.screenMain)

        fileio.check_config()

        self.show_all()

        if music.music.playing:
            music.music.play()


class ScreenMain(Gtk.Grid):
    def __init__(self):
        Gtk.Grid.__init__(self)
        self.set_row_spacing(40)
        self.set_border_width(5)

        buttonbox = Gtk.ButtonBox()
        buttonbox.set_hexpand(True)
        buttonbox.set_vexpand(True)
        buttonbox.set_orientation(Gtk.Orientation.VERTICAL)
        buttonbox.set_layout(Gtk.ButtonBoxStyle.EXPAND)
        buttonbox.set_border_width(25)
        self.attach(buttonbox, 1, 1, 1, 1)

        buttonNewGame = widgets.Button("_New Game")
        buttonNewGame.set_tooltip_text("Start a new game")
        buttonNewGame.connect("clicked", self.new_game_clicked)
        buttonbox.add(buttonNewGame)
        buttonLoadGame = widgets.Button("_Load Game")
        buttonLoadGame.set_tooltip_text("Load a previously saved game")
        buttonLoadGame.connect("clicked", self.load_game_clicked)
        buttonbox.add(buttonLoadGame)
        buttonDeleteGame = widgets.Button("_Delete Game")
        buttonDeleteGame.set_tooltip_text("Delete a previously saved game")
        buttonDeleteGame.connect("clicked", self.delete_game_clicked)
        buttonbox.add(buttonDeleteGame)
        buttonPreferences = widgets.Button("_Preferences")
        buttonPreferences.set_tooltip_text("Adjust game settings")
        buttonPreferences.connect("clicked", self.preferences_dialog_clicked)
        buttonbox.add(buttonPreferences)
        buttonEditor = widgets.Button("_Data Editor")
        buttonEditor.set_tooltip_text("Create new or edit existing game database")
        buttonEditor.connect("clicked", self.editor_clicked)
        buttonbox.add(buttonEditor)
        buttonQuit = widgets.Button("_Quit")
        buttonQuit.set_tooltip_text("Quit the game")
        buttonQuit.connect("clicked", exit_game)
        buttonbox.add(buttonQuit)

        self.buttonInfo = widgets.Button()
        self.buttonInfo.set_relief(Gtk.ReliefStyle.NONE)
        self.buttonInfo.set_label("Version %s (Build %s)" % (version.VERSION,
                                                             version.DATE))
        self.buttonInfo.connect("clicked", self.information_button_clicked)
        self.attach(self.buttonInfo, 0, 2, 1, 1)

        label = Gtk.Label()
        label.set_markup("<a href='%s'>%s Website</a>" % (version.WEBSITE,
                                                          version.NAME))
        label.set_alignment(1, 0.5)
        self.attach(label, 2, 2, 1, 1)

    def new_game_clicked(self, button):
        game.window.remove(game.window.screenMain)
        game.window.add(game.window.screenDetails)
        game.window.screenDetails.run()

    def load_game_clicked(self, button):
        dialog = interface.OpenDialog()

        if dialog.display():
            game.window.remove(game.window.screenMain)
            game.window.add(game.window.screenGame)
            game.window.screen_loader(game.active_screen_id)
            game.window.screenGame.run()

    def delete_game_clicked(self, button):
        dialog = interface.DeleteDialog()
        dialog.display()

    def editor_clicked(self, button):
        try:
            filepath = os.path.join("editor", "editor")
            subprocess.Popen(filepath, shell=False)
        except FileNotFoundError:
            dialogs.editor_not_found_error()

    def preferences_dialog_clicked(self, button):
        dialog = interface.PreferencesDialog()
        dialog.display()

    def information_button_clicked(self, button):
        dialog = interface.AboutDialog()
        dialog.display()


class ScreenDetails(Gtk.Grid):
    '''
    Grab details for the game including manager name, club and finances.
    '''
    def __init__(self):
        Gtk.Grid.__init__(self)
        self.set_row_spacing(5)
        self.set_column_spacing(5)
        self.set_border_width(5)

        self.liststoreName = Gtk.ListStore(str)
        self.liststoreYears = Gtk.ListStore(int)
        self.liststoreLeagues = Gtk.ListStore(int, str)
        self.liststoreClubs = Gtk.ListStore(int, str)

        treemodelsort = Gtk.TreeModelSort(self.liststoreClubs)
        treemodelsort.set_sort_column_id(1, Gtk.SortType.ASCENDING)

        label = widgets.AlignedLabel("_Name")
        self.attach(label, 0, 0, 1, 1)
        self.comboboxName = Gtk.ComboBoxText.new_with_entry()
        self.comboboxName.set_model(self.liststoreName)
        self.entryName = self.comboboxName.get_child()
        self.entryName.connect("changed", self.continue_status)
        label.set_mnemonic_widget(self.comboboxName)
        self.attach(self.comboboxName, 1, 0, 1, 1)

        label = widgets.AlignedLabel("_Database")
        self.attach(label, 0, 1, 1, 1)
        self.filechooserDatabase = Gtk.FileChooserButton()
        self.filechooserDatabase.set_title("Select Database")
        self.filechooserDatabase.set_action(Gtk.FileChooserAction.OPEN)
        self.filechooserDatabase.connect("file-set", self.file_chooser_set)
        filefilter = Gtk.FileFilter()
        filefilter.set_name("Database Files")
        filefilter.add_pattern("*.db")
        self.filechooserDatabase.add_filter(filefilter)
        label.set_mnemonic_widget(self.filechooserDatabase)
        self.attach(self.filechooserDatabase, 1, 1, 1, 1)

        cellrenderertext = Gtk.CellRendererText()

        label = widgets.AlignedLabel("_Year")
        self.attach(label, 0, 2, 1, 1)
        self.comboboxYear = Gtk.ComboBox()
        self.comboboxYear.set_model(self.liststoreYears)
        self.comboboxYear.pack_start(cellrenderertext, True)
        self.comboboxYear.add_attribute(cellrenderertext, "text", 0)
        self.comboboxYear.connect("changed", self.year_changed)
        label.set_mnemonic_widget(self.comboboxYear)
        self.attach(self.comboboxYear, 1, 2, 1, 1)

        label = widgets.AlignedLabel("_League")
        self.attach(label, 0, 3, 1, 1)
        self.comboboxLeague = Gtk.ComboBox()
        self.comboboxLeague.set_model(self.liststoreLeagues)
        self.comboboxLeague.pack_start(cellrenderertext, True)
        self.comboboxLeague.add_attribute(cellrenderertext, "text", 1)
        self.comboboxLeague.connect("changed", self.league_changed)
        label.set_mnemonic_widget(self.comboboxLeague)
        self.attach(self.comboboxLeague, 1, 3, 1, 1)

        label = widgets.AlignedLabel("_Club")
        self.attach(label, 0, 4, 1, 1)
        self.comboboxClub = Gtk.ComboBox()
        self.comboboxClub.set_model(treemodelsort)
        self.comboboxClub.pack_start(cellrenderertext, True)
        self.comboboxClub.add_attribute(cellrenderertext, "text", 1)
        self.comboboxClub.connect("changed", self.continue_status)
        label.set_mnemonic_widget(self.comboboxClub)
        self.attach(self.comboboxClub, 1, 4, 1, 1)

        label = widgets.AlignedLabel("_Finances")
        self.attach(label, 0, 5, 1, 1)
        self.radiobuttonFinancesRep = Gtk.RadioButton("Reputation-Based Finances")
        self.radiobuttonFinancesRep.connect("toggled", self.finances_changed)
        label.set_mnemonic_widget(self.radiobuttonFinancesRep)
        self.attach(self.radiobuttonFinancesRep, 1, 5, 1, 1)
        self.radiobuttonFinancesUSM = Gtk.RadioButton("USM-Based Finances")
        self.radiobuttonFinancesUSM.join_group(self.radiobuttonFinancesRep)
        self.radiobuttonFinancesUSM.connect("toggled", self.finances_changed)
        self.attach(self.radiobuttonFinancesUSM, 2, 5, 1, 1)
        self.comboboxFinances = Gtk.ComboBoxText()
        self.comboboxFinances.set_sensitive(False)
        self.attach(self.comboboxFinances, 1, 6, 2, 1)

        buttonbox = Gtk.ButtonBox()
        buttonbox.set_spacing(5)
        buttonbox.set_layout(Gtk.ButtonBoxStyle.END)
        self.attach(buttonbox, 0, 7, 3, 1)
        buttonBack = widgets.Button("_Back")
        buttonBack.connect("clicked", self.back_button_clicked)
        buttonbox.add(buttonBack)
        self.buttonContinue = widgets.Button("_Continue")
        self.buttonContinue.set_sensitive(False)
        self.buttonContinue.connect("clicked", self.continue_button_clicked)
        buttonbox.add(self.buttonContinue)

    def run(self):
        # Load financials
        self.comboboxFinances.remove_all()

        for key, item in constants.money.items():
            amount = display.currency(item[0])
            self.comboboxFinances.append(str(key), "%s (%s)" % (item[1], amount))

        # Load manager names
        self.manager_names = [name for name in fileio.read_names()]

        self.liststoreName.clear()

        for name in self.manager_names:
            self.liststoreName.append([name])

        self.entryName.set_text("")
        self.radiobuttonFinancesRep.set_active(True)
        self.comboboxFinances.set_active(0)

        if game.database.connect():
            # Set database to open
            filepath = os.path.join("databases", "%s" % (game.database_filename))
            self.filechooserDatabase.select_filename(filepath)

            self.load_year_list()

        self.show_all()
        self.entryName.grab_focus()

    def year_changed(self, combobox=None):
        self.load_league_list()

    def league_changed(self, combobox=None):
        self.load_club_list()

    def load_year_list(self):
        year_data = game.database.cursor.execute("SELECT * FROM year ORDER BY year ASC")

        self.liststoreYears.clear()

        for year in year_data.fetchall():
            self.liststoreYears.append([year[0]])

        self.comboboxYear.set_active(0)

    def load_league_list(self):
        model = self.comboboxYear.get_model()
        treeiter = self.comboboxYear.get_active()

        if treeiter != -1:
            year = model[treeiter][0]

            league_data = game.database.cursor.execute("SELECT league.id, league.name FROM league JOIN leagueattr ON leagueattr.league = league.id WHERE year = ?", (year,))

            self.liststoreLeagues.clear()

            for league in league_data.fetchall():
                self.liststoreLeagues.append([league[0], league[1]])

            sensitive = len(self.liststoreLeagues) > 0
            self.comboboxLeague.set_sensitive(sensitive)
            self.comboboxLeague.set_active(0)

    def load_club_list(self):
        active = self.comboboxYear.get_active()
        year = self.liststoreYears[active][0]

        active = self.comboboxLeague.get_active()

        if active != -1:
            league = self.liststoreLeagues[active][0]

            club_data = game.database.cursor.execute("SELECT club.id, club.name FROM club JOIN clubattr ON clubattr.club = club.id WHERE year = ? AND league = ?", (year, league))

            self.liststoreClubs.clear()

            for club in club_data.fetchall():
                self.liststoreClubs.append([club[0], club[1]])

            sensitive = len(self.liststoreClubs) > 0
            self.comboboxClub.set_sensitive(sensitive)
            self.comboboxClub.set_active(0)
        else:
            sensitive = len(self.liststoreClubs) > 0
            self.comboboxClub.set_sensitive(sensitive)
            self.liststoreClubs.clear()

    def file_chooser_set(self, filechooserbutton):
        game.database_filename = filechooserbutton.get_filename()
        game.database.connect(game.database_filename)

        preferences.preferences["DATABASE"]["Database"] = game.database_filename
        preferences.preferences.writefile()

        self.load_year_list()

    def finances_changed(self, radiobutton):
        active = self.radiobuttonFinancesUSM.get_active()
        self.comboboxFinances.set_sensitive(active)

    def continue_status(self, widget=None):
        sensitive = self.entryName.get_text_length() > 0

        if sensitive:
            sensitive = self.comboboxClub.get_active() != -1

        self.buttonContinue.set_sensitive(sensitive)

    def back_button_clicked(self, button):
        game.window.remove(game.window.screenDetails)
        game.window.add(game.window.screenMain)

    def continue_button_clicked(self, button):
        active = self.comboboxYear.get_active()
        game.date.year = int(self.liststoreYears[active][0])

        # Get club ID number from combobox
        treeiter = self.comboboxClub.get_active_iter()
        model = self.comboboxClub.get_model()
        game.teamid = model[treeiter][0]

        data.datainit()

        # Save manager name entered by player
        manager = self.entryName.get_text()
        game.clubs[game.teamid].manager = manager

        if manager in self.manager_names:
            self.manager_names.remove(manager)

        self.manager_names.insert(0, manager)

        names = [name for name in self.manager_names]
        fileio.write_names(names)

        # Grab finance setup
        if self.radiobuttonFinancesUSM.get_active():
            finance = int(self.comboboxFinances.get_active_id())
        else:
            finance = -1

        data.dataloader(finance)

        game.database.connection.close()

        game.window.remove(game.window.screenDetails)
        game.window.add(game.window.screenGame)
        game.window.screen_loader(game.start_screen)
        game.window.screenGame.run()


class ScreenGame(Gtk.Grid):
    def __init__(self):
        Gtk.Grid.__init__(self)

        game.menu = menu.Menu()
        self.attach(game.menu, 0, 0, 1, 1)

        game.menu.menuitemNew.connect("activate", self.new_game_clicked)
        game.menu.menuitemLoad.connect("activate", self.load_game_clicked)
        game.menu.menuitemSave.connect("activate", self.save_game_clicked)
        game.menu.menuitemDelete.connect("activate", self.delete_game_clicked)
        game.menu.menuitemPrint.connect("activate", self.print_clicked)
        game.menu.menuitemQuit.connect("activate", exit_game)

        game.menu.menuitemManager.connect("activate", self.name_change)
        game.menu.menuitemPreferences.connect("activate", self.preferences_dialog_clicked)

        game.menu.menuitemPlayers.connect("activate", lambda i: game.window.screen_loader(20))
        game.menu.menuitemComparison.connect("activate", self.player_comparison)
        game.menu.menuitemNews.connect("activate", lambda i: game.window.screen_loader(3))
        game.menu.menuitemFixtures.connect("activate", lambda i: game.window.screen_loader(2))
        game.menu.menuitemResults.connect("activate", lambda i: game.window.screen_loader(6))
        game.menu.menuitemStandings.connect("activate", lambda i: game.window.screen_loader(5))
        game.menu.menuitemCharts.connect("activate", lambda i: game.window.screen_loader(30))
        game.menu.menuitemEvaluation.connect("activate", lambda i: game.window.screen_loader(25))
        game.menu.menuitemOpposition.connect("activate", self.view_opposition)
        game.menu.menuitemNegotiations.connect("activate", lambda i: game.window.screen_loader(21))
        game.menu.menuitemShortlist.connect("activate", lambda i: game.window.screen_loader(22))
        game.menu.menuitemStatistics.connect("activate", lambda i: game.window.screen_loader(29))

        game.menu.menuitemStadium.connect("activate", lambda i: game.window.screen_loader(10))
        game.menu.menuitemBuildings.connect("activate", lambda i: game.window.screen_loader(14))
        game.menu.menuitemTickets.connect("activate", lambda i: game.window.screen_loader(19))
        game.menu.menuitemSponsorship.connect("activate", lambda i: dialogs.sponsorship())
        game.menu.menuitemAdvertising.connect("activate", lambda i: game.window.screen_loader(16))
        game.menu.menuitemMerchandise.connect("activate", lambda i: game.window.screen_loader(17))
        game.menu.menuitemCatering.connect("activate", lambda i: game.window.screen_loader(18))
        game.menu.menuitemFinances.connect("activate", lambda i: game.window.screen_loader(11))
        game.menu.menuitemAccounts.connect("activate", lambda i: game.window.screen_loader(12))

        game.menu.menuitemSquad.connect("activate", lambda i: game.window.screen_loader(1))
        game.menu.menuitemTactics.connect("activate", lambda i: game.window.screen_loader(4))
        game.menu.menuitemTeamTraining.connect("activate", lambda i: game.window.screen_loader(7))
        game.menu.menuitemIndTraining.connect("activate", lambda i: game.window.screen_loader(9))
        game.menu.menuitemTrainingCamp.connect("activate", lambda i: game.window.screen_loader(8))
        game.menu.menuitemInjSus.connect("activate", lambda i: game.window.screen_loader(24))
        game.menu.menuitemStaff.connect("activate", lambda i: game.window.screen_loader(23))

        game.menu.menuitemContents.connect("activate", self.help_content_clicked)
        game.menu.menuitemInformation.connect("activate", self.info_dialog_clicked)
        game.menu.menuitemAbout.connect("activate", self.aboutdialog_clicked)

        grid = Gtk.Grid()
        grid.set_border_width(1)
        grid.set_column_spacing(5)
        self.attach(grid, 0, 2, 1, 1)

        widgets.date.update()
        grid.attach(widgets.date, 0, 0, 1, 1)

        widgets.news.connect("clicked", self.news_activated)
        grid.attach(widgets.news, 1, 0, 1, 1)

        label = Gtk.Label()  # Intentional blank label
        label.set_hexpand(True)
        grid.attach(label, 2, 0, 1, 1)

        game.labelNextMatch = Gtk.Label()
        grid.attach(game.labelNextMatch, 3, 0, 1, 1)

        widgets.continuegame = widgets.Button("_Continue Game")
        widgets.continuegame.connect("clicked", continuegame.continue_game)
        grid.attach(widgets.continuegame, 4, 0, 1, 1)

    def run(self):
        self.show_all()

    def name_change(self, menuitem):
        club = game.clubs[game.teamid]
        previous = club.manager

        name_change = interface.NameChange()

        if name_change.display():
            game.news.set_manager_name(previous)

            game.window.screen_loader(game.active_screen_id)

    def news_activated(self, button):
        game.window.screen_loader(3)

    def player_comparison(self, menuitem):
        if dialogs.comparison.comparison == [None, None]:
            dialogs.error(3)
        elif not dialogs.comparison.comparison[0] or not dialogs.comparison.comparison[1]:
            dialogs.error(5)
        else:
            dialogs.comparison.display()

    def view_opposition(self, menuitem):
        opposition_dialog = dialogs.Opposition()
        opposition_dialog.display()

    def new_game_clicked(self, menuitem):
        exit_dialog = interface.ExitDialog()

        if not exit_dialog.display(leave=True):
            game.window.remove(game.window.screenGame)
            game.window.add(game.window.screenMain)

            # Reset teamid to zero to prevent having to confirm quit
            game.teamid = None

    def load_game_clicked(self, menuitem):
        open_dialog = interface.OpenDialog()

        if open_dialog.display():
            game.window.screen_loader(game.active_screen_id)

    def save_game_clicked(self, menuitem):
        save_dialog = interface.SaveDialog()
        save_dialog.display()
        save_dialog.destroy()

    def delete_game_clicked(self, menuitem):
        delete_dialog = interface.DeleteDialog()
        delete_dialog.display()

    def print_clicked(self, menuitem):
        print_dialog = printing.PrintType()
        print_dialog.display()

    def preferences_dialog_clicked(self, menuitem):
        preferences_dialog = interface.PreferencesDialog()
        preferences_dialog.display()

        game.window.screen_loader(game.active_screen_id)

    def aboutdialog_clicked(self, menuitem):
        aboutdialog = interface.AboutDialog()
        aboutdialog.display()

    def help_content_clicked(self, menuitem):
        helpdialog = interface.HelpDialog()
        helpdialog.display()

    def info_dialog_clicked(self, menuitem):
        infodialog = interface.InfoDialog()
        infodialog.display()


class ContinueGame:
    proceed = True

    def continue_game(self, widget):
        update_valid = True

        current_date = "%i/%i" % (game.date.day, game.date.month)

        if game.date.week == len(constants.dates):
            if game.dateindex == len(constants.dates[game.date.week - 1]) - 1:
                # End of season events
                events.end_of_season()

        if game.eventindex <= len(constants.events) - 1:
            event = constants.events[game.eventindex]
        else:
            event = None

        if current_date == event:
            # Team names to be passed to proceed dialog
            for item in game.fixtures[game.fixturesindex]:
                if game.teamid in (item[0], item[1]):
                    match = item

            if game.teamid == match[0]:
                opposition = game.clubs[match[1]].name
            else:
                opposition = game.clubs[match[0]].name

            error = True

            if dialogs.proceed_to_game(opposition):
                error = self.check_squad()

                if error:
                    update_valid = False
            else:
                update_valid = False

            if not error:
                game.eventindex += 1
                game.window.screen_loader(99)
                self.proceed = False
        elif self.proceed and update_valid:
            self.update_date()
        elif not self.proceed:
            game.window.screen_loader(1)

            game.menu.set_sensitive(True)
            widgets.news.set_sensitive(True)
            self.proceed = True

        # Unread news status
        if game.news.get_unread_count() > 0:
            widgets.news.show()

        # Display next match
        current_date = "%i/%i" % (game.date.day, game.date.month)

        if current_date == constants.events[game.fixturesindex]:
            for match in game.fixtures[game.fixturesindex]:
                if game.teamid in match:
                    team1 = game.clubs[match[0]].name
                    team2 = game.clubs[match[1]].name
                    game.labelNextMatch.set_label("Today's Match: %s - %s" % (team1, team2))
        else:
            game.labelNextMatch.set_label("")

    def update_date(self):
        club = game.clubs[game.teamid]

        game.date.day = constants.dates[game.date.week - 1][game.dateindex]

        if game.dateprev > game.date.day:
            game.dateprev = 0

            if game.date.month == 12:
                game.date.end_of_year()
            else:
                game.date.month += 1

        if len(constants.dates[game.date.week - 1]) - 1 > game.dateindex:
            game.dateindex += 1
        else:
            game.dateprev = constants.dates[game.date.week - 1][game.dateindex]
            game.dateindex = 0
            game.date.week += 1

            # Process end of week events
            events.reset_accounts()
            money.pay_wages()
            events.update_contracts()
            events.update_advertising()
            club.sponsorship.update()
            events.refresh_staff()
            events.team_training()
            events.individual_training()
            ai.renew_contract()
            events.injury_period()
            events.update_condition()
            events.update_maintenance()
            money.float_club()
            money.pay_overdraft()
            money.pay_loan()
            money.process_grant()

        # Process everyday events
        transfer.transfer()
        events.injury()
        ai.advertising()
        evaluation.update()
        aitransfer.identify()
        staff.check_morale()

        # Initiate sponsorship generation if needed
        if (game.date.day, game.date.month) == (4, 8):
            if club.sponsorship.status == 0:
                club.sponsorship.generate()

        # Stop sale of season tickets and deposit earnings
        if (game.date.day, game.date.month) == (16, 8):
            if game.season_tickets_status == 0:
                game.season_tickets_status = 1

                sales.season_tickets()

        # Player value adjustments
        for playerid, player in game.players.items():
            player.value = calculator.value(playerid)

        widgets.date.update()

        # Reload screen after each continue game
        game.window.screen_loader(game.active_screen_id)

    def check_squad(self):
        '''
        Check whether the squad has been selected, determine the numbers
        and return whether the game can proceed or not.
        '''
        class Errors:
            team_count = 0
            injuries = []
            suspensions = []
            errored = False

        errors = Errors()

        error = False
        team_count = 0
        sub_count = 0

        for positionid, playerid in game.clubs[game.teamid].team.items():
            if playerid:
                player = game.players[playerid]

                if player.injury_type != 0:
                    errors.injuries.append(player)
                    errors.errored = True

                if player.suspension_type != 0:
                    errors.suspensions.append(player)
                    errors.errored = True

            if playerid != 0:
                if positionid < 11:
                    team_count += 1

                if positionid >= 11:
                    sub_count += 1

        errors.team_count = team_count

        if team_count < 11:
            errors.errored = True
        elif sub_count < 5:
            if not dialogs.not_enough_subs(sub_count):
                error = True

        if errors.errored:
            error = True

            dialog = dialogs.SquadReport()
            dialog.display(errors)

        return error


def exit_game(widget=None, event=None):
    def update_window_config():
        '''
        Save the window size and state to preferences when quitting.
        '''
        if game.window.is_maximized():
            preferences.preferences["INTERFACE"]["Maximized"] = "True"
        else:
            preferences.preferences["INTERFACE"]["Maximized"] = "False"

            width, height = game.window.get_size()
            preferences.preferences["INTERFACE"]["Width"] = str(width)
            preferences.preferences["INTERFACE"]["Height"] = str(height)

            xposition, yposition = game.window.get_position()
            preferences.preferences["INTERFACE"]["XPosition"] = str(xposition)
            preferences.preferences["INTERFACE"]["YPosition"] = str(yposition)

        preferences.preferences.writefile()

    if game.teamid is None:
        update_window_config()
        Gtk.main_quit()
    else:
        exit_dialog = interface.ExitDialog()
        state = exit_dialog.display()

        if not state:
            update_window_config()
            Gtk.main_quit()

        return state


game.date = structures.Date()
game.database = database.Database()
continuegame = ContinueGame()
preferences.preferences = preferences.Preferences()
music.music = music.Player()

widgets.date = widgets.Date()
widgets.news = widgets.News()

game.window = Window()
game.window.run()

dialogs.comparison = dialogs.Comparison()


if __name__ == "__main__":
    Gtk.main()
